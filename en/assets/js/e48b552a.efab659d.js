"use strict";(self.webpackChunkalgorithm_essentials=self.webpackChunkalgorithm_essentials||[]).push([[4135],{15680:(e,n,r)=>{r.d(n,{xA:()=>p,yg:()=>b});var a=r(96540);function t(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,a)}return r}function d(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){t(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function i(e,n){if(null==e)return{};var r,a,t=function(e,n){if(null==e)return{};var r,a,t={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],n.indexOf(r)>=0||(t[r]=e[r]);return t}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var l=a.createContext({}),s=function(e){var n=a.useContext(l),r=n;return e&&(r="function"==typeof e?e(n):d(d({},n),e)),r},p=function(e){var n=s(e.components);return a.createElement(l.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var r=e.components,t=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=s(r),h=t,b=c["".concat(l,".").concat(h)]||c[h]||u[h]||o;return r?a.createElement(b,d(d({ref:n},p),{},{components:r})):a.createElement(b,d({ref:n},p))}));function b(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var o=r.length,d=new Array(o);d[0]=h;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[c]="string"==typeof e?e:t,d[1]=i;for(var s=2;s<o;s++)d[s]=r[s];return a.createElement.apply(null,d)}return a.createElement.apply(null,r)}h.displayName="MDXCreateElement"},19365:(e,n,r)=>{r.d(n,{A:()=>d});var a=r(96540),t=r(20053);const o={tabItem:"tabItem_Ymn6"};function d(e){let{children:n,hidden:r,className:d}=e;return a.createElement("div",{role:"tabpanel",className:(0,t.A)(o.tabItem,d),hidden:r},n)}},4865:(e,n,r)=>{r.d(n,{A:()=>u});var a=r(58168),t=r(96540),o=r(20053),d=r(92303),i=r(31682),l=r(86976),s=r(23104);const p={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function c(e){const{lazy:n,block:r,defaultValue:d,values:c,groupId:u,className:h}=e,b=t.Children.map(e.children,(e=>{if((0,t.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),g=c??b.map((e=>{let{props:{value:n,label:r,attributes:a}}=e;return{value:n,label:r,attributes:a}})),m=(0,i.X)(g,((e,n)=>e.value===n.value));if(m.length>0)throw new Error(`Docusaurus error: Duplicate values "${m.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const v=null===d?d:d??b.find((e=>e.props.default))?.props.value??b[0].props.value;if(null!==v&&!g.some((e=>e.value===v)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${v}" but none of its children has the corresponding value. Available values are: ${g.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:f}=(0,l.x)(),[N,G]=(0,t.useState)(v),w=[],{blockElementScrollPositionUntilNextRender:U}=(0,s.a_)();if(null!=u){const e=y[u];null!=e&&e!==N&&g.some((n=>n.value===e))&&G(e)}const O=e=>{const n=e.currentTarget,r=w.indexOf(n),a=g[r].value;a!==N&&(U(n),G(a),null!=u&&f(u,String(a)))},T=e=>{let n=null;switch(e.key){case"ArrowRight":{const r=w.indexOf(e.currentTarget)+1;n=w[r]??w[0];break}case"ArrowLeft":{const r=w.indexOf(e.currentTarget)-1;n=w[r]??w[w.length-1];break}}n?.focus()};return t.createElement("div",{className:(0,o.A)("tabs-container",p.tabList)},t.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":r},h)},g.map((e=>{let{value:n,label:r,attributes:d}=e;return t.createElement("li",(0,a.A)({role:"tab",tabIndex:N===n?0:-1,"aria-selected":N===n,key:n,ref:e=>w.push(e),onKeyDown:T,onFocus:O,onClick:O},d,{className:(0,o.A)("tabs__item",p.tabItem,d?.className,{"tabs__item--active":N===n})}),r??n)}))),n?(0,t.cloneElement)(b.filter((e=>e.props.value===N))[0],{className:"margin-top--md"}):t.createElement("div",{className:"margin-top--md"},b.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==N})))))}function u(e){const n=(0,d.A)();return t.createElement(c,(0,a.A)({key:String(n)},e))}},81125:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>b,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=r(58168),t=(r(96540),r(15680)),o=r(4865),d=r(19365);const i={title:"Clone Graph"},l=void 0,s={unversionedId:"graph/clone-graph",id:"graph/clone-graph",title:"Clone Graph",description:"\u63cf\u8ff0",source:"@site/docs/graph/clone-graph.md",sourceDirName:"graph",slug:"/graph/clone-graph",permalink:"/en/graph/clone-graph",draft:!1,tags:[],version:"current",frontMatter:{title:"Clone Graph"},sidebar:"docs",previous:{title:"\u56fe",permalink:"/en/graph/"},next:{title:"Graph Valid Tree",permalink:"/en/graph/graph-valid-tree"}},p={},c=[{value:"\u63cf\u8ff0",id:"\u63cf\u8ff0",level:3},{value:"\u5206\u6790",id:"\u5206\u6790",level:3},{value:"DFS",id:"dfs",level:3},{value:"BFS",id:"bfs",level:3}],u={toc:c},h="wrapper";function b(e){let{components:n,...r}=e;return(0,t.yg)(h,(0,a.A)({},u,r,{components:n,mdxType:"MDXLayout"}),(0,t.yg)("h3",{id:"\u63cf\u8ff0"},"\u63cf\u8ff0"),(0,t.yg)("p",null,"Clone an undirected graph. Each node in the graph contains a ",(0,t.yg)("inlineCode",{parentName:"p"},"label")," and a list of its ",(0,t.yg)("inlineCode",{parentName:"p"},"neighbours"),"."),(0,t.yg)("p",null,"OJ's undirected graph serialization:\nNodes are labeled uniquely."),(0,t.yg)("p",null,"We use ",(0,t.yg)("inlineCode",{parentName:"p"},"#")," as a separator for each node, and ",(0,t.yg)("inlineCode",{parentName:"p"},",")," as a separator for node label and each neighbour of the node.\nAs an example, consider the serialized graph ",(0,t.yg)("inlineCode",{parentName:"p"},"{0,1,2#1,2#2,2}"),"."),(0,t.yg)("p",null,"The graph has a total of three nodes, and therefore contains three parts as separated by ",(0,t.yg)("inlineCode",{parentName:"p"},"#"),"."),(0,t.yg)("ol",null,(0,t.yg)("li",{parentName:"ol"},"First node is labeled as 0. Connect node 0 to both nodes 1 and 2."),(0,t.yg)("li",{parentName:"ol"},"Second node is labeled as 1. Connect node 1 to node 2."),(0,t.yg)("li",{parentName:"ol"},"Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.")),(0,t.yg)("p",null,"Visually, the graph looks like the following:"),(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre"},"       1\n      / \\\n     /   \\\n    0 --- 2\n         / \\\n         \\_/\n")),(0,t.yg)("h3",{id:"\u5206\u6790"},"\u5206\u6790"),(0,t.yg)("p",null,"\u5e7f\u5ea6\u4f18\u5148\u904d\u5386\u6216\u6df1\u5ea6\u4f18\u5148\u904d\u5386\u90fd\u53ef\u4ee5\u3002"),(0,t.yg)("h3",{id:"dfs"},"DFS"),(0,t.yg)(o.A,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],mdxType:"Tabs"},(0,t.yg)(d.A,{value:"java",mdxType:"TabItem"},(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-java"},"// Clone Graph\n// DFS\uff0c\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        if(node == null) return null;\n        // key is original node\uff0cvalue is copied node\n        HashMap<UndirectedGraphNode, UndirectedGraphNode> visited = new HashMap<>();\n        clone(node, visited);\n        return visited.get(node);\n    }\n    // DFS\n    private static UndirectedGraphNode clone(UndirectedGraphNode node,\n                                              HashMap<UndirectedGraphNode,\n                                                      UndirectedGraphNode> visited) {\n        // a copy already exists\n        if (visited.containsKey(node)) return visited.get(node);\n\n        UndirectedGraphNode new_node = new UndirectedGraphNode(node.label);\n        visited.put(node, new_node);\n        for (UndirectedGraphNode nbr : node.neighbors)\n            new_node.neighbors.add(clone(nbr, visited));\n        return new_node;\n    }\n}\n"))),(0,t.yg)(d.A,{value:"cpp",mdxType:"TabItem"},(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-cpp"},"// Clone Graph\n// DFS\uff0c\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    UndirectedGraphNode *cloneGraph(const UndirectedGraphNode *node) {\n        if(node == nullptr) return nullptr;\n        // key is original node\uff0cvalue is copied node\n        unordered_map<const UndirectedGraphNode *,\n                            UndirectedGraphNode *> visited;\n        clone(node, visited);\n        return visited[node];\n    }\nprivate:\n    // DFS\n    static UndirectedGraphNode* clone(const UndirectedGraphNode *node,\n            unordered_map<const UndirectedGraphNode *,\n            UndirectedGraphNode *> &visited) {\n        // a copy already exists\n        if (visited.find(node) != visited.end()) return visited[node];\n\n        UndirectedGraphNode *new_node = new UndirectedGraphNode(node->label);\n        visited[node] = new_node;\n        for (auto nbr : node->neighbors)\n            new_node->neighbors.push_back(clone(nbr, visited));\n        return new_node;\n    }\n};\n")))),(0,t.yg)("h3",{id:"bfs"},"BFS"),(0,t.yg)(o.A,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],mdxType:"Tabs"},(0,t.yg)(d.A,{value:"java",mdxType:"TabItem"},(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-java"},"// Clone Graph\n// BFS\uff0c\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {\n        if (node == null) return null;\n        // key is original node\uff0cvalue is copied node\n        HashMap<UndirectedGraphNode,UndirectedGraphNode> visited = new HashMap<>();\n        // each node in queue is already copied itself\n        // but neighbors are not copied yet\n        Queue<UndirectedGraphNode> q = new LinkedList<>();\n        q.offer(node);\n        visited.put(node, new UndirectedGraphNode(node.label));\n        while (!q.isEmpty()) {\n            UndirectedGraphNode cur = q.poll();\n            for (UndirectedGraphNode nbr : cur.neighbors) {\n                // a copy already exists\n                if (visited.containsKey(nbr)) {\n                    visited.get(cur).neighbors.add(visited.get(nbr));\n                } else {\n                    UndirectedGraphNode new_node =\n                            new UndirectedGraphNode(nbr.label);\n                    visited.put(nbr, new_node);\n                    visited.get(cur).neighbors.add(new_node);\n                    q.offer(nbr);\n                }\n            }\n        }\n        return visited.get(node);\n    }\n}\n"))),(0,t.yg)(d.A,{value:"cpp",mdxType:"TabItem"},(0,t.yg)("pre",null,(0,t.yg)("code",{parentName:"pre",className:"language-cpp"},"// Clone Graph\n// BFS\uff0c\u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    UndirectedGraphNode *cloneGraph(const UndirectedGraphNode *node) {\n        if (node == nullptr) return nullptr;\n        // key is original node\uff0cvalue is copied node\n        unordered_map<const UndirectedGraphNode *,\n                            UndirectedGraphNode *> copied;\n        // each node in queue is already copied itself\n        // but neighbors are not copied yet\n        queue<const UndirectedGraphNode *> q;\n        q.push(node);\n        copied[node] = new UndirectedGraphNode(node->label);\n        while (!q.empty()) {\n            const UndirectedGraphNode *cur = q.front();\n            q.pop();\n            for (auto nbr : cur->neighbors) {\n                // a copy already exists\n                if (copied.find(nbr) != copied.end()) {\n                    copied[cur]->neighbors.push_back(copied[nbr]);\n                } else {\n                    UndirectedGraphNode *new_node =\n                            new UndirectedGraphNode(nbr->label);\n                    copied[nbr] = new_node;\n                    copied[cur]->neighbors.push_back(new_node);\n                    q.push(nbr);\n                }\n            }\n        }\n        return copied[node];\n    }\n};\n")))))}b.isMDXComponent=!0}}]);