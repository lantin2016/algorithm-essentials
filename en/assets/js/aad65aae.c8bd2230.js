"use strict";(self.webpackChunkalgorithm_essentials=self.webpackChunkalgorithm_essentials||[]).push([[8819],{15680:(t,n,e)=>{e.d(n,{xA:()=>u,yg:()=>h});var r=e(96540);function a(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function s(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,r)}return e}function i(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?s(Object(e),!0).forEach((function(n){a(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):s(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function o(t,n){if(null==t)return{};var e,r,a=function(t,n){if(null==t)return{};var e,r,a={},s=Object.keys(t);for(r=0;r<s.length;r++)e=s[r],n.indexOf(e)>=0||(a[e]=t[e]);return a}(t,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(r=0;r<s.length;r++)e=s[r],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(a[e]=t[e])}return a}var l=r.createContext({}),d=function(t){var n=r.useContext(l),e=n;return t&&(e="function"==typeof t?t(n):i(i({},n),t)),e},u=function(t){var n=d(t.components);return r.createElement(l.Provider,{value:n},t.children)},c="mdxType",p={inlineCode:"code",wrapper:function(t){var n=t.children;return r.createElement(r.Fragment,{},n)}},g=r.forwardRef((function(t,n){var e=t.components,a=t.mdxType,s=t.originalType,l=t.parentName,u=o(t,["components","mdxType","originalType","parentName"]),c=d(e),g=a,h=c["".concat(l,".").concat(g)]||c[g]||p[g]||s;return e?r.createElement(h,i(i({ref:n},u),{},{components:e})):r.createElement(h,i({ref:n},u))}));function h(t,n){var e=arguments,a=n&&n.mdxType;if("string"==typeof t||a){var s=e.length,i=new Array(s);i[0]=g;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=t,o[c]="string"==typeof t?t:a,i[1]=o;for(var d=2;d<s;d++)i[d]=e[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,e)}g.displayName="MDXCreateElement"},19365:(t,n,e)=>{e.d(n,{A:()=>i});var r=e(96540),a=e(20053);const s={tabItem:"tabItem_Ymn6"};function i(t){let{children:n,hidden:e,className:i}=t;return r.createElement("div",{role:"tabpanel",className:(0,a.A)(s.tabItem,i),hidden:e},n)}},4865:(t,n,e)=>{e.d(n,{A:()=>p});var r=e(58168),a=e(96540),s=e(20053),i=e(92303),o=e(31682),l=e(86976),d=e(23104);const u={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function c(t){const{lazy:n,block:e,defaultValue:i,values:c,groupId:p,className:g}=t,h=a.Children.map(t.children,(t=>{if((0,a.isValidElement)(t)&&"value"in t.props)return t;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof t.type?t.type:t.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),f=c??h.map((t=>{let{props:{value:n,label:e,attributes:r}}=t;return{value:n,label:e,attributes:r}})),w=(0,o.X)(f,((t,n)=>t.value===n.value));if(w.length>0)throw new Error(`Docusaurus error: Duplicate values "${w.map((t=>t.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const v=null===i?i:i??h.find((t=>t.props.default))?.props.value??h[0].props.value;if(null!==v&&!f.some((t=>t.value===v)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${v}" but none of its children has the corresponding value. Available values are: ${f.map((t=>t.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:y,setTabGroupChoices:S}=(0,l.x)(),[m,_]=(0,a.useState)(v),b=[],{blockElementScrollPositionUntilNextRender:L}=(0,d.a_)();if(null!=p){const t=y[p];null!=t&&t!==m&&f.some((n=>n.value===t))&&_(t)}const A=t=>{const n=t.currentTarget,e=b.indexOf(n),r=f[e].value;r!==m&&(L(n),_(r),null!=p&&S(p,String(r)))},x=t=>{let n=null;switch(t.key){case"ArrowRight":{const e=b.indexOf(t.currentTarget)+1;n=b[e]??b[0];break}case"ArrowLeft":{const e=b.indexOf(t.currentTarget)-1;n=b[e]??b[b.length-1];break}}n?.focus()};return a.createElement("div",{className:(0,s.A)("tabs-container",u.tabList)},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":e},g)},f.map((t=>{let{value:n,label:e,attributes:i}=t;return a.createElement("li",(0,r.A)({role:"tab",tabIndex:m===n?0:-1,"aria-selected":m===n,key:n,ref:t=>b.push(t),onKeyDown:x,onFocus:A,onClick:A},i,{className:(0,s.A)("tabs__item",u.tabItem,i?.className,{"tabs__item--active":m===n})}),e??n)}))),n?(0,a.cloneElement)(h.filter((t=>t.props.value===m))[0],{className:"margin-top--md"}):a.createElement("div",{className:"margin-top--md"},h.map(((t,n)=>(0,a.cloneElement)(t,{key:n,hidden:t.props.value!==m})))))}function p(t){const n=(0,i.A)();return a.createElement(c,(0,r.A)({key:String(n)},t))}},43867:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>u,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>c});var r=e(58168),a=(e(96540),e(15680)),s=e(4865),i=e(19365);const o={title:"Word Ladder II"},l=void 0,d={unversionedId:"bfs/graph/word-ladder-ii",id:"bfs/graph/word-ladder-ii",title:"Word Ladder II",description:"\u63cf\u8ff0",source:"@site/docs/bfs/graph/word-ladder-ii.md",sourceDirName:"bfs/graph",slug:"/bfs/graph/word-ladder-ii",permalink:"/en/bfs/graph/word-ladder-ii",draft:!1,tags:[],version:"current",frontMatter:{title:"Word Ladder II"},sidebar:"docs",previous:{title:"Word Ladder",permalink:"/en/bfs/graph/word-ladder"},next:{title:"Surrounded Regions",permalink:"/en/bfs/graph/surrounded-regions"}},u={},c=[{value:"\u63cf\u8ff0",id:"\u63cf\u8ff0",level:3},{value:"\u5206\u6790",id:"\u5206\u6790",level:3},{value:"\u5355\u961f\u5217",id:"\u5355\u961f\u5217",level:3},{value:"\u53cc\u961f\u5217",id:"\u53cc\u961f\u5217",level:3},{value:"\u56fe\u7684\u5e7f\u641c",id:"\u56fe\u7684\u5e7f\u641c",level:3},{value:"\u76f8\u5173\u9898\u76ee",id:"\u76f8\u5173\u9898\u76ee",level:3}],p={toc:c},g="wrapper";function h(t){let{components:n,...e}=t;return(0,a.yg)(g,(0,r.A)({},p,e,{components:n,mdxType:"MDXLayout"}),(0,a.yg)("h3",{id:"\u63cf\u8ff0"},"\u63cf\u8ff0"),(0,a.yg)("p",null,"Given two words (start and end), and a dictionary, find all shortest transformation sequence(s) from start to end, such that:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"Only one letter can be changed at a time"),(0,a.yg)("li",{parentName:"ul"},"Each intermediate word must exist in the dictionary")),(0,a.yg)("p",null,"For example, Given:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},'start = "hit"\nend = "cog"\ndict = ["hot","dot","dog","lot","log"]\n')),(0,a.yg)("p",null,"Return"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},'[\n    ["hit","hot","dot","dog","cog"],\n    ["hit","hot","lot","log","cog"]\n]\n')),(0,a.yg)("p",null,"Note:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"All words have the same length."),(0,a.yg)("li",{parentName:"ul"},"All words contain only lowercase alphabetic characters.")),(0,a.yg)("h3",{id:"\u5206\u6790"},"\u5206\u6790"),(0,a.yg)("p",null,"\u8ddf Word Ladder \u6bd4\uff0c\u8fd9\u9898\u662f\u6c42\u8def\u5f84\u672c\u8eab\uff0c\u4e0d\u662f\u8def\u5f84\u957f\u5ea6\uff0c\u4e5f\u662f BFS\uff0c\u7565\u5fae\u9ebb\u70e6\u70b9\u3002"),(0,a.yg)("p",null,"\u6c42\u4e00\u6761\u8def\u5f84\u548c\u6c42\u6240\u6709\u8def\u5f84\u6709\u5f88\u5927\u7684\u4e0d\u540c\uff0c\u6c42\u4e00\u6761\u8def\u5f84\uff0c\u6bcf\u4e2a\u72b6\u6001\u8282\u70b9\u53ea\u9700\u8981\u8bb0\u5f55\u4e00\u4e2a\u524d\u9a71\u5373\u53ef\uff1b\u6c42\u6240\u6709\u8def\u5f84\u65f6\uff0c\u6709\u7684\u72b6\u6001\u8282\u70b9\u53ef\u80fd\u6709\u591a\u4e2a\u7236\u8282\u70b9\uff0c\u5373\u8981\u8bb0\u5f55\u591a\u4e2a\u524d\u9a71\u3002"),(0,a.yg)("p",null,"\u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\u3002"),(0,a.yg)("h3",{id:"\u5355\u961f\u5217"},"\u5355\u961f\u5217"),(0,a.yg)(s.A,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],mdxType:"Tabs"},(0,a.yg)(i.A,{value:"java",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord,\n                                          Set<String> wordList) {\n        Queue<String> q = new LinkedList<>();\n        HashMap<String, Integer> visited = new HashMap<>(); // \u5224\u91cd\n        HashMap<String, ArrayList<String>> father = new HashMap<>(); // DAG\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, HashSet<String> > stateExtend = (String s) -> {\n            HashSet<String> result = new HashSet<>();\n\n            char[] array = s.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newState = new String(array);\n                    final int newDepth = visited.get(s) + 1;\n\n                    if (stateIsValid.apply(newState)) {\n                        if (visited.containsKey(newState)) {\n                            final int depth = visited.get(newState);\n                            if (depth < newDepth) {\n                                // do nothing\n                            } else if (depth == newDepth) {\n                                result.add(newState);\n                            } else {\n                                throw new IllegalStateException(\"not possible to get here\");\n                            }\n\n                        } else {\n                            result.add(newState);\n                        }\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        List<List<String>> result = new ArrayList<>();\n        q.offer(beginWord);\n        visited.put(beginWord, 0);\n        while (!q.isEmpty()) {\n            String state = q.poll();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.isEmpty() && (visited.get(state) + 1) > result.get(0).size()) break;\n\n            if (stateIsTarget.apply(state)) {\n                ArrayList<String> path = new ArrayList<>();\n                genPath(father, beginWord, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            HashSet<String> newStates = stateExtend.apply(state);\n            for (String newState : newStates) {\n                if (!visited.containsKey(newState)) {\n                    q.offer(newState);\n                    visited.put(newState, visited.get(state)+1);\n                }\n                ArrayList<String> parents = father.getOrDefault(newState, new ArrayList<>());\n                parents.add(state);\n                father.put(newState, parents);\n            }\n        }\n        return result;\n    }\n    private static void genPath(HashMap<String, ArrayList<String>> father,\n                                String start, String state, List<String> path,\n                                List<List<String>> result) {\n        path.add(state);\n        if (state.equals(start)) {\n            if (!result.isEmpty()) {\n                if (path.size() < result.get(0).size()) {\n                    result.clear();\n                } else if (path.size() == result.get(0).size()) {\n                    // do nothing\n                } else {\n                    throw new IllegalStateException(\"not possible to get here\");\n                }\n            }\n            ArrayList<String> tmp = new ArrayList<>(path);\n            Collections.reverse(tmp);\n            result.add(tmp);\n        } else {\n            for (String f : father.get(state)) {\n                genPath(father, start, f, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n}\n"))),(0,a.yg)(i.A,{value:"cpp",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    vector<vector<string> > findLadders(const string& start,\n        const string& end, const unordered_set<string> &dict) {\n        queue<string> q;\n        unordered_map<string, int> visited; // \u5224\u91cd\n        unordered_map<string, vector<string> > father; // DAG\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end; };\n        auto state_extend = [&](const string &s) {\n            unordered_set<string> result;\n            const int new_depth = visited[s] + 1;\n\n            for (size_t i = 0; i < s.size(); ++i) {\n                string new_state = s;\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_state[i]) continue;\n\n                    swap(c, new_state[i]);\n\n                    if (state_is_valid(new_state)) {\n                        auto visited_iter = visited.find(new_state);\n\n                        if (visited_iter != visited.end()) {\n                            const int depth = visited_iter->second;\n                            if (depth < new_depth) {\n                                // do nothing\n                            }\n                            else if (depth == new_depth) {\n                                result.insert(new_state);\n                            }\n                            else { // not possible\n                                throw std::logic_error(\"not possible to get here\");\n                            }\n                        }\n                        else {\n                            result.insert(new_state);\n                        }\n                    }\n                    swap(c, new_state[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        vector<vector<string>> result;\n        q.push(start);\n        visited[start] = 0;\n        while (!q.empty()) {\n            // \u5343\u4e07\u4e0d\u80fd\u7528 const auto&\uff0cpop() \u4f1a\u5220\u9664\u5143\u7d20\uff0c\n            // \u5f15\u7528\u5c31\u53d8\u6210\u4e86\u60ac\u7a7a\u5f15\u7528\n            const auto state = q.front();\n            q.pop();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.empty() && visited[state] + 1 > result[0].size()) break;\n\n            if (state_is_target(state)) {\n                vector<string> path;\n                gen_path(father, start, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            const auto& new_states = state_extend(state);\n            for (const auto& new_state : new_states) {\n                if (visited.find(new_state) == visited.end()) {\n                    q.push(new_state);\n                    visited[new_state] = visited[state] + 1;\n                }\n                father[new_state].push_back(state);\n            }\n        }\n\n        return result;\n    }\nprivate:\n    void gen_path(unordered_map<string, vector<string> > &father,\n        const string &start, const string &state, vector<string> &path,\n        vector<vector<string> > &result) {\n        path.push_back(state);\n        if (state == start) {\n            if (!result.empty()) {\n                if (path.size() < result[0].size()) {\n                    result.clear();\n                }\n                else if (path.size() == result[0].size()) {\n                    // do nothing\n                }\n                else { // not possible\n                    throw std::logic_error(\"not possible to get here \");\n                }\n            }\n            result.push_back(path);\n            reverse(result.back().begin(), result.back().end());\n        }\n        else {\n            for (const auto& f : father[state]) {\n                gen_path(father, start, f, path, result);\n            }\n        }\n        path.pop_back();\n    }\n};\n")))),(0,a.yg)("h3",{id:"\u53cc\u961f\u5217"},"\u53cc\u961f\u5217"),(0,a.yg)(s.A,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],mdxType:"Tabs"},(0,a.yg)(i.A,{value:"java",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord,\n                                          Set<String> wordList) {\n        // \u5f53\u524d\u5c42\uff0c\u4e0b\u4e00\u5c42\uff0c\u7528unordered_set\u662f\u4e3a\u4e86\u53bb\u91cd\uff0c\u4f8b\u5982\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\n        // \u540c\u4e00\u4e2a\u5b50\u8282\u70b9\uff0c\u5982\u679c\u7528vector, \u5b50\u8282\u70b9\u5c31\u4f1a\u5728next\u91cc\u51fa\u73b0\u4e24\u6b21\uff0c\u5176\u5b9e\u6b64\n        // \u65f6 father \u5df2\u7ecf\u8bb0\u5f55\u4e86\u4e24\u4e2a\u7236\u8282\u70b9\uff0cnext\u91cc\u91cd\u590d\u51fa\u73b0\u4e24\u6b21\u662f\u6ca1\u5fc5\u8981\u7684\n        HashSet<String> current = new HashSet<>();\n        HashSet<String> next = new HashSet<>();\n        HashSet<String> visited = new HashSet<>(); // \u5224\u91cd\n        HashMap<String, ArrayList<String>> father = new HashMap<>(); // DAG\n        int level = -1; // \u5c42\u6b21\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, HashSet<String> > stateExtend = (String s) -> {\n            HashSet<String> result = new HashSet<>();\n\n            char[] array = s.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newState = new String(array);\n\n                    if (stateIsValid.apply(newState) &&\n                            !visited.contains(newState)) {\n                        result.add(newState);\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        List<List<String>> result = new ArrayList<>();\n        current.add(beginWord);\n        while (!current.isEmpty()) {\n            ++ level;\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.isEmpty() && level + 1 > result.get(0).size()) break;\n\n            // 1. \u5ef6\u8fdf\u52a0\u5165visited, \u8fd9\u6837\u624d\u80fd\u5141\u8bb8\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\u540c\u4e00\u4e2a\u5b50\u8282\u70b9\n            // 2. \u4e00\u80a1\u8111current \u5168\u90e8\u52a0\u5165visited, \u662f\u9632\u6b62\u672c\u5c42\u524d\u4e00\u4e2a\u8282\u70b9\u6269\u5c55\n            // \u8282\u70b9\u65f6\uff0c\u6307\u5411\u4e86\u672c\u5c42\u540e\u9762\u5c1a\u672a\u5904\u7406\u7684\u8282\u70b9\uff0c\u8fd9\u6761\u8def\u5f84\u5fc5\u7136\u4e0d\u662f\u6700\u77ed\u7684\n            for (String state : current)\n                visited.add(state);\n\n            for (String state : current) {\n                if (stateIsTarget.apply(state)) {\n                    ArrayList<String> path = new ArrayList<>();\n                    genPath(father, beginWord, state, path, result);\n                    continue;\n                }\n                // \u6269\u5c55\u8282\u70b9\n                HashSet<String> newStates = stateExtend.apply(state);\n                for (String newState : newStates) {\n                    next.add(newState);\n                    ArrayList<String> parents = father.getOrDefault(newState, new ArrayList<>());\n                    parents.add(state);\n                    father.put(newState, parents);\n                }\n            }\n            current.clear();\n            // swap\n            HashSet<String> tmp = current;\n            current = next;\n            next = tmp;\n\n        }\n        return result;\n    }\n    private static void genPath(HashMap<String, ArrayList<String>> father,\n                                String start, String state, List<String> path,\n                                List<List<String>> result) {\n        path.add(state);\n        if (state.equals(start)) {\n            if (!result.isEmpty()) {\n                if (path.size() < result.get(0).size()) {\n                    result.clear();\n                } else if (path.size() == result.get(0).size()) {\n                    // do nothing\n                } else {\n                    throw new IllegalStateException(\"not possible to get here\");\n                }\n            }\n            ArrayList<String> tmp = new ArrayList<>(path);\n            Collections.reverse(tmp);\n            result.add(tmp);\n        } else {\n            for (String f : father.get(state)) {\n                genPath(father, start, f, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n}\n"))),(0,a.yg)(i.A,{value:"cpp",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    vector<vector<string> > findLadders(const string& start,\n            const string& end, const unordered_set<string> &dict) {\n        // \u5f53\u524d\u5c42\uff0c\u4e0b\u4e00\u5c42\uff0c\u7528unordered_set\u662f\u4e3a\u4e86\u53bb\u91cd\uff0c\u4f8b\u5982\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\n        // \u540c\u4e00\u4e2a\u5b50\u8282\u70b9\uff0c\u5982\u679c\u7528vector, \u5b50\u8282\u70b9\u5c31\u4f1a\u5728next\u91cc\u51fa\u73b0\u4e24\u6b21\uff0c\u5176\u5b9e\u6b64\n        // \u65f6 father \u5df2\u7ecf\u8bb0\u5f55\u4e86\u4e24\u4e2a\u7236\u8282\u70b9\uff0cnext\u91cc\u91cd\u590d\u51fa\u73b0\u4e24\u6b21\u662f\u6ca1\u5fc5\u8981\u7684\n        unordered_set<string> current, next;\n        unordered_set<string> visited; // \u5224\u91cd\n        unordered_map<string, vector<string> > father; // DAG\n\n        int level = -1;  // \u5c42\u6b21\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end;};\n        auto state_extend = [&](const string &s) {\n            unordered_set<string> result;\n\n            for (size_t i = 0; i < s.size(); ++i) {\n                string new_word(s);\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_word[i]) continue;\n\n                    swap(c, new_word[i]);\n\n                    if (state_is_valid(new_word) &&\n                            visited.find(new_word) == visited.end()) {\n                        result.insert(new_word);\n                    }\n                    swap(c, new_word[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n\n            return result;\n        };\n\n        vector<vector<string> > result;\n        current.insert(start);\n        while (!current.empty()) {\n            ++ level;\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\n            // \u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.empty() && level+1 > result[0].size()) break;\n\n            // 1. \u5ef6\u8fdf\u52a0\u5165visited, \u8fd9\u6837\u624d\u80fd\u5141\u8bb8\u4e24\u4e2a\u7236\u8282\u70b9\u6307\u5411\u540c\u4e00\u4e2a\u5b50\u8282\u70b9\n            // 2. \u4e00\u80a1\u8111current \u5168\u90e8\u52a0\u5165visited, \u662f\u9632\u6b62\u672c\u5c42\u524d\u4e00\u4e2a\u8282\u70b9\u6269\u5c55\n            // \u8282\u70b9\u65f6\uff0c\u6307\u5411\u4e86\u672c\u5c42\u540e\u9762\u5c1a\u672a\u5904\u7406\u7684\u8282\u70b9\uff0c\u8fd9\u6761\u8def\u5f84\u5fc5\u7136\u4e0d\u662f\u6700\u77ed\u7684\n            for (const auto& state : current)\n                visited.insert(state);\n            for (const auto& state : current) {\n                if (state_is_target(state)) {\n                    vector<string> path;\n                    gen_path(father, path, start, state, result);\n                    continue;\n                }\n\n                const auto new_states = state_extend(state);\n                for (const auto& new_state : new_states) {\n                    next.insert(new_state);\n                    father[new_state].push_back(state);\n                }\n            }\n\n            current.clear();\n            swap(current, next);\n        }\n\n        return result;\n    }\nprivate:\n    void gen_path(unordered_map<string, vector<string> > &father,\n            vector<string> &path, const string &start, const string &word,\n            vector<vector<string> > &result) {\n        path.push_back(word);\n        if (word == start) {\n            if (!result.empty()) {\n                if (path.size() < result[0].size()) {\n                    result.clear();\n                    result.push_back(path);\n                } else if(path.size() == result[0].size()) {\n                    result.push_back(path);\n                } else {\n                    // not possible\n                    throw std::logic_error(\"not possible to get here\");\n                }\n            } else {\n                result.push_back(path);\n            }\n            reverse(result.back().begin(), result.back().end());\n        } else {\n            for (const auto& f : father[word]) {\n                gen_path(father, path, start, f, result);\n            }\n        }\n        path.pop_back();\n    }\n};\n")))),(0,a.yg)("h3",{id:"\u56fe\u7684\u5e7f\u641c"},"\u56fe\u7684\u5e7f\u641c"),(0,a.yg)("p",null,"\u524d\u9762\u7684\u89e3\u6cd5\uff0c\u5728\u72b6\u6001\u6269\u5c55\u7684\u65f6\u5019\uff0c\u6bcf\u6b21\u90fd\u662f\u4ece'a'\u5230'z'\u5168\u90e8\u679a\u4e3e\u4e00\u904d\uff0c\u91cd\u590d\u8ba1\u7b97\uff0c\u6bd4\u8f83\u6d6a\u8d39\uff0c\u5176\u5b9e\u5f53\u7ed9\u5b9a\u5b57\u5178",(0,a.yg)("inlineCode",{parentName:"p"},"dict"),"\u540e\uff0c\u5355\u8bcd\u4e0e\u5355\u8bcd\u4e4b\u95f4\u7684\u8def\u5f84\u5c31\u56fa\u5b9a\u4e0b\u6765\u4e86\uff0c\u672c\u8d28\u4e0a\u5355\u8bcd\u4e0e\u5355\u8bcd\u4e4b\u95f4\u6784\u6210\u4e86\u4e00\u4e2a\u65e0\u5411\u56fe\u3002\u5982\u679c\u4e8b\u5148\u628a\u8fd9\u4e2a\u56fe\u6784\u5efa\u51fa\u6765\uff0c\u90a3\u4e48\u72b6\u6001\u6269\u5c55\u5c31\u4f1a\u5927\u5927\u52a0\u5feb\u3002"),(0,a.yg)(s.A,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],mdxType:"Tabs"},(0,a.yg)(i.A,{value:"java",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"import java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Function;\n\n// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord,\n                                          Set<String> wordList) {\n        Queue<String> q = new LinkedList<>();\n        HashMap<String, Integer> visited = new HashMap<>(); // \u5224\u91cd\n        HashMap<String, ArrayList<String>> father = new HashMap<>(); // DAG\n        // only used by stateExtend()\n        final HashMap<String, HashSet<String>> g = buildGraph(wordList);\n\n        final Function<String, Boolean> stateIsValid = (String s) ->\n                wordList.contains(s) || s.equals(endWord);\n        final Function<String, Boolean> stateIsTarget = (String s) ->\n                s.equals(endWord);\n\n        final Function<String, List<String> > stateExtend = (String s) -> {\n            List<String> result = new ArrayList<>();\n            final int newDepth = visited.get(s) + 1;\n            HashSet<String> list = g.get(s);\n            if (list == null) return result;\n\n            for (String newState : list) {\n                if (stateIsValid.apply(newState)) {\n                    if (visited.containsKey(newState)) {\n                        final int depth = visited.get(newState);\n                        if (depth < newDepth) {\n                            // do nothing\n                        } else if (depth == newDepth) {\n                            result.add(newState);\n                        } else {\n                            throw new IllegalStateException(\"not possible to get here\");\n                        }\n\n                    } else {\n                        result.add(newState);\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        List<List<String>> result = new ArrayList<>();\n        q.offer(beginWord);\n        visited.put(beginWord, 0);\n        while (!q.isEmpty()) {\n            String state = q.poll();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.isEmpty() && (visited.get(state) + 1) > result.get(0).size()) break;\n\n            if (stateIsTarget.apply(state)) {\n                ArrayList<String> path = new ArrayList<>();\n                genPath(father, beginWord, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            List<String> newStates = stateExtend.apply(state);\n            for (String newState : newStates) {\n                if (!visited.containsKey(newState)) {\n                    q.offer(newState);\n                    visited.put(newState, visited.get(state)+1);\n                }\n                ArrayList<String> parents = father.getOrDefault(newState, new ArrayList<>());\n                parents.add(state);\n                father.put(newState, parents);\n            }\n        }\n        return result;\n    }\n    private static void genPath(HashMap<String, ArrayList<String>> father,\n                                String start, String state, List<String> path,\n                                List<List<String>> result) {\n        path.add(state);\n        if (state.equals(start)) {\n            if (!result.isEmpty()) {\n                if (path.size() < result.get(0).size()) {\n                    result.clear();\n                } else if (path.size() == result.get(0).size()) {\n                    // do nothing\n                } else {\n                    throw new IllegalStateException(\"not possible to get here\");\n                }\n            }\n            ArrayList<String> tmp = new ArrayList<>(path);\n            Collections.reverse(tmp);\n            result.add(tmp);\n        } else {\n            for (String f : father.get(state)) {\n                genPath(father, start, f, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n\n    private static HashMap<String, HashSet<String>> buildGraph(Set<String> dict) {\n        HashMap<String, HashSet<String>> adjacency_list = new HashMap<>();\n        for (String word: dict) {\n            char[] array = word.toCharArray();\n            for (int i = 0; i < array.length; ++i) {\n                final char old = array[i];\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == array[i]) continue;\n\n                    array[i] = c;\n                    String newWord = new String(array);\n\n                    if (dict.contains(newWord)) {\n                        HashSet<String> list = adjacency_list.getOrDefault(\n                                word, new HashSet<>());\n                        list.add(newWord);\n                        adjacency_list.put(word, list);\n                    }\n                    array[i] = old; // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n        }\n        return adjacency_list;\n    }\n}\n"))),(0,a.yg)(i.A,{value:"cpp",mdxType:"TabItem"},(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-cpp"},"// Word Ladder II\n// \u65f6\u95f4\u590d\u6742\u5ea6O(n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6O(n)\nclass Solution {\npublic:\n    vector<vector<string> > findLadders(const string& start,\n        const string& end, const unordered_set<string> &dict) {\n        queue<string> q;\n        unordered_map<string, int> visited; // \u5224\u91cd\n        unordered_map<string, vector<string> > father; // DAG\n        // only used by state_extend()\n        const unordered_map<string, unordered_set<string> >& g = build_graph(dict);\n\n        auto state_is_valid = [&](const string& s) {\n            return dict.find(s) != dict.end() || s == end;\n        };\n        auto state_is_target = [&](const string &s) {return s == end; };\n        auto state_extend = [&](const string &s) {\n            vector<string> result;\n            const int new_depth = visited[s] + 1;\n            auto iter = g.find(s);\n            if (iter == g.end()) return result;\n            const auto& list = iter->second;\n\n            for (const auto& new_state : list) {\n                if (state_is_valid(new_state)) {\n                    auto visited_iter = visited.find(new_state);\n                    if (visited_iter != visited.end()) {\n                        const int depth = visited_iter->second;\n                        if (depth < new_depth) {\n                            // do nothing\n                        }\n                        else if (depth == new_depth) {\n                            result.push_back(new_state);\n                        } else { // not possible\n                            throw std::logic_error(\"not possible to get here\");\n                        }\n                    }\n                    else {\n                        result.push_back(new_state);\n                    }\n                }\n            }\n\n            return result;\n        };\n\n        vector<vector<string>> result;\n        q.push(start);\n        visited[start] = 0;\n        while (!q.empty()) {\n            // \u5343\u4e07\u4e0d\u80fd\u7528 const auto&\uff0cpop() \u4f1a\u5220\u9664\u5143\u7d20\uff0c\n            // \u5f15\u7528\u5c31\u53d8\u6210\u4e86\u60ac\u7a7a\u5f15\u7528\n            const auto state = q.front();\n            q.pop();\n\n            // \u5982\u679c\u5f53\u524d\u8def\u5f84\u957f\u5ea6\u5df2\u7ecf\u8d85\u8fc7\u5f53\u524d\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff0c\n            // \u53ef\u4ee5\u4e2d\u6b62\u5bf9\u8be5\u8def\u5f84\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u627e\u7684\u662f\u6700\u77ed\u8def\u5f84\n            if (!result.empty() && visited[state] + 1 > result[0].size()) break;\n\n            if (state_is_target(state)) {\n                vector<string> path;\n                gen_path(father, start, state, path, result);\n                continue;\n            }\n            // \u5fc5\u987b\u632a\u5230\u4e0b\u9762\uff0c\u6bd4\u5982\u540c\u4e00\u5c42A\u548cB\u4e24\u4e2a\u8282\u70b9\u5747\u6307\u5411\u4e86\u76ee\u6807\u8282\u70b9\uff0c\n            // \u90a3\u4e48\u76ee\u6807\u8282\u70b9\u5c31\u4f1a\u5728q\u4e2d\u51fa\u73b0\u4e24\u6b21\uff0c\u8f93\u51fa\u8def\u5f84\u5c31\u4f1a\u7ffb\u500d\n            // visited.insert(state);\n\n            // \u6269\u5c55\u8282\u70b9\n            const auto& new_states = state_extend(state);\n            for (const auto& new_state : new_states) {\n                if (visited.find(new_state) == visited.end()) {\n                    q.push(new_state);\n                    visited[new_state] = visited[state] + 1;\n                }\n                father[new_state].push_back(state);\n            }\n        }\n\n        return result;\n    }\nprivate:\n    void gen_path(unordered_map<string, vector<string> > &father,\n        const string &start, const string &state, vector<string> &path,\n        vector<vector<string> > &result) {\n        path.push_back(state);\n        if (state == start) {\n            if (!result.empty()) {\n                if (path.size() < result[0].size()) {\n                    result.clear();\n                }\n                else if (path.size() == result[0].size()) {\n                    // do nothing\n                }\n                else { // not possible\n                    throw std::logic_error(\"not possible to get here \");\n                }\n            }\n            result.push_back(path);\n            reverse(result.back().begin(), result.back().end());\n        }\n        else {\n            for (const auto& f : father[state]) {\n                gen_path(father, start, f, path, result);\n            }\n        }\n        path.pop_back();\n    }\n    unordered_map<string, unordered_set<string> > build_graph(\n        const unordered_set<string>& dict) {\n        unordered_map<string, unordered_set<string> > adjacency_list;\n\n        for (const auto& word : dict) {\n            for (size_t i = 0; i < word.size(); ++i) {\n                string new_word(word);\n                for (char c = 'a'; c <= 'z'; c++) {\n                    // \u9632\u6b62\u540c\u5b57\u6bcd\u66ff\u6362\n                    if (c == new_word[i]) continue;\n\n                    swap(c, new_word[i]);\n\n                    if ((dict.find(new_word) != dict.end())) {\n                        auto iter = adjacency_list.find(word);\n                        if (iter != adjacency_list.end()) {\n                            iter->second.insert(new_word);\n                        }\n                        else {\n                            adjacency_list.insert(pair<string,\n                                unordered_set<string >> (word, unordered_set<string>()));\n                            adjacency_list[word].insert(new_word);\n                        }\n                    }\n                    swap(c, new_word[i]); // \u6062\u590d\u8be5\u5355\u8bcd\n                }\n            }\n        }\n        return adjacency_list;\n    }\n};\n")))),(0,a.yg)("h3",{id:"\u76f8\u5173\u9898\u76ee"},"\u76f8\u5173\u9898\u76ee"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("a",{parentName:"li",href:"/en/bfs/graph/word-ladder"},"Word Ladder"))))}h.isMDXComponent=!0}}]);